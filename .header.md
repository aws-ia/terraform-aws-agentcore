# Bedrock AgentCore Module

The [Amazon Bedrock AgentCore](https://aws.amazon.com/bedrock/agentcore/) Terraform module provides a high-level, object-oriented approach to creating and managing Amazon Bedrock AgentCore resources using Terraform. This module abstracts away the complexity of the L1 resources and provides a higher level implementation.

## Overview

The module provides support for Amazon Bedrock AgentCore Runtime, Runtime Endpoints, Memories, and Gateways. This allows you to deploy custom container-based runtimes for your Bedrock agents, create memory resources that provide long-term contextual awareness, and establish gateways which serve as integration points between agents and external services.

This module simplifies the process of:

- Creating and configuring Bedrock AgentCore Runtimes
- Setting up AgentCore Runtime Endpoints
- Implementing AgentCore Memory with various memory strategies
- Creating and managing AgentCore Gateways
- Managing IAM permissions for your runtimes, memories, and gateways
- Configuring network access and security settings

## Features

- **Custom Container Support**: Deploy your own container images from Amazon ECR
- **Flexible Networking**: Support for both PUBLIC and VPC network modes for runtimes, and SANDBOX and VPC modes for code interpreters
- **IAM Role Management**: Automatic creation of IAM roles with appropriate permissions
- **Environment Variables**: Pass configuration to your runtime container
- **JWT Authorization**: Optional JWT authorizer configuration for secure access
- **Endpoint Management**: Create and manage runtime endpoints for client access
- **Memory Management**: Create and configure memory resources for persistent contextual awareness
- **Multiple Memory Strategies**: Support for semantic, summary, user preference, and custom memory strategies
- **Namespace Organization**: Organize memory data with customizable namespaces for different actors and sessions
- **Custom Memory Consolidation**: Override prompts and models for memory extraction and consolidation
- **Gateway Support**: Create and manage AgentCore Gateways for model context communication
- **Protocol Configuration**: Configure MCP protocol settings for gateways
- **Gateway Security**: Implement JWT authorization and KMS encryption for gateways
- **Granular Permissions**: Control gateway create, read, update, and delete permissions
- **OAuth2 Outbound Authorization**: Configure OAuth client for gateway outbound authorization
- **API Key Outbound Authorization**: Configure API key for gateway outbound authorization
- **Code Interpreter**: Create and manage custom code interpreter resources for Bedrock agents
- **Browser Custom**: Create and manage custom browser resources for Bedrock agents with recording capabilities

## Usage

### AgentCore Runtime and Endpoint

```hcl
module "agentcore" {
  source  = "aws-ia/agentcore/aws"
  version = "0.0.2"

  # Enable Agent Core Runtime
  create_runtime = true
  runtime_name = "MyCustomRuntime"
  runtime_description = "Custom runtime for my Bedrock agent"
  runtime_container_uri = "123456789012.dkr.ecr.us-east-1.amazonaws.com/bedrock/agent-runtime:latest"
  runtime_network_mode = "PUBLIC"
  # Environment variables for the runtime
  runtime_environment_variables = {
    "LOG_LEVEL" = "INFO"
    "ENV" = "production"
  }
  # Enable Agent Core Runtime Endpoint
  create_runtime_endpoint = true
  runtime_endpoint_name = "MyRuntimeEndpoint"
  runtime_endpoint_description = "Endpoint for my custom runtime"
}
```

#### With JWT Authorization

```hcl
module "agentcore" {
  source  = "aws-ia/agentcore/aws"
  version = "0.0.2"

  # Enable Agent Core Runtime
  create_runtime = true
  runtime_name = "SecureRuntime"
  runtime_container_uri = "123456789012.dkr.ecr.us-east-1.amazonaws.com/bedrock/agent-runtime:latest"

  # Configure JWT authorization
  runtime_authorizer_configuration = {
    custom_jwt_authorizer = {
      discovery_url = "https://cognito-idp.us-east-1.amazonaws.com/us-east-1_example/.well-known/jwks.json"
      allowed_audience = ["client-id-1", "client-id-2"]
    }
  }

  # Enable Agent Core Runtime Endpoint
  create_runtime_endpoint = true
  runtime_endpoint_name = "SecureEndpoint"
}
```

#### With Custom IAM Role

```hcl
module "agentcore" {
  source  = "aws-ia/agentcore/aws"
  version = "0.0.2"

  # Enable Agent Core Runtime with custom IAM role
  create_runtime = true
  runtime_name = "CustomRoleRuntime"
  runtime_container_uri = "123456789012.dkr.ecr.us-east-1.amazonaws.com/bedrock/agent-runtime:latest"
  runtime_role_arn = "arn:aws:iam::123456789012:role/my-custom-bedrock-role"

  # Enable Agent Core Runtime Endpoint
  create_runtime_endpoint = true
  runtime_endpoint_name = "CustomRoleEndpoint"
}
```

### AgentCore Gateway

Create and configure an MCP gateway:

```hcl
module "agentcore" {
  source  = "aws-ia/agentcore/aws"
  version = "0.0.2"

  # Enable Agent Core Gateway
  create_gateway = true
  gateway_name = "MyMCPGateway"
  gateway_description = "Gateway for Model Context Protocol connections"

  # Configure the gateway protocol (MCP)
  gateway_protocol_type = "MCP"
  gateway_protocol_configuration = {
    mcp = {
      instructions = "Custom instructions for MCP tools and resources"
      search_type = "DEFAULT"
      supported_versions = ["1.0.0"]
    }
  }

  # Optional JWT authorization
  gateway_authorizer_type = "CUSTOM_JWT"
  gateway_authorizer_configuration = {
    custom_jwt_authorizer = {
      discovery_url = "https://cognito-idp.us-east-1.amazonaws.com/us-east-1_example/.well-known/jwks.json"
      allowed_audience = ["client-id-1", "client-id-2"]
    }
  }

  # Optional KMS encryption
  gateway_kms_key_arn = "<INSERT_KEY_HERE>"

  # Manage gateway permissions
  gateway_allow_create_permissions = true
  gateway_allow_update_delete_permissions = true
}
```

#### Automatic Cognito User Pool Creation

The module can automatically create a Cognito User Pool to handle JWT authentication when no JWT auth information is provided:

```hcl
module "agentcore" {
  source  = "aws-ia/agentcore/aws"
  version = "0.0.2"

  # Enable Agent Core Gateway
  create_gateway = true
  gateway_name = "GatewayWithAutoCognito"
  gateway_authorizer_type = "CUSTOM_JWT"
  # No gateway_authorizer_configuration - a Cognito User Pool will be created automatically

}
```

In this scenario, the module will:

1. Create a Cognito User Pool
2. Configure a domain for the User Pool
3. Set up a User Pool client with the necessary OAuth configuration
4. Configure the gateway's JWT authorizer to use the User Pool

### AgentCore Memory

Memory is a critical component of intelligence. While Large Language Models (LLMs) have impressive capabilities, they lack persistent memory across conversations. Amazon Bedrock AgentCore Memory addresses this limitation by providing a managed service that enables AI agents to maintain context over time, remember important facts, and deliver consistent, personalized experiences.

AgentCore Memory operates on two levels:

- **Short-Term Memory**: Immediate conversation context and session-based information that provides continuity within a single interaction or closely related sessions.
- **Long-Term Memory**: Persistent information extracted and stored across multiple conversations, including facts, preferences, and summaries that enable personalized experiences over time.

When you interact with the memory, you store interactions in Short-Term Memory (STM) instantly. These interactions can include everything from user messages, assistant responses, to tool actions.

To write to long-term memory, you need to configure extraction strategies which define how and where to store information from conversations for future use. These strategies are asynchronously processed from raw events after every few turns based on the strategy that was selected. You can't create long term memory records directly, as they are extracted asynchronously by AgentCore Memory.

#### Basic Memory Creation

Below you can find how to configure a simple short-term memory (STM) with no long-term memory extraction strategies. Note how you set `memory_event_expiry_duration`, which defines the time in days the events will be stored in the short-term memory before they expire.

```hcl
module "agentcore" {
  source  = "aws-ia/agentcore/aws"
  version = "0.0.2"

  # Create a basic memory with default settings, no LTM strategies
  create_memory = true
  memory_name = "my_memory"
  memory_description = "A memory for storing user interactions for a period of 90 days"
  memory_event_expiry_duration = 90
}
```

Basic Memory with Custom KMS Encryption

```hcl
# Create a custom KMS key for encryption
resource "aws_kms_key" "memory_encryption_key" {
  enable_key_rotation = true
  description         = "KMS key for memory encryption"
}

module "agentcore" {
  source  = "aws-ia/agentcore/aws"
  version = "0.0.2"

  # Create memory with custom encryption
  create_memory = true
  memory_name = "my_encrypted_memory"
  memory_description = "Memory with custom KMS encryption"
  memory_event_expiry_duration = 90
  memory_kms_key_arn = aws_kms_key.memory_encryption_key.arn
}
```

#### Memory with Built-in Strategies

The library provides three built-in LTM strategies. These are default strategies for organizing and extracting memory data, each optimized for specific use cases.

For example: An agent helps multiple users with cloud storage setup. From these conversations, see how each strategy processes users expressing confusion about account connection:

#### Summarization Strategy

This strategy compresses conversations into concise overviews, preserving essential context and key insights for quick recall. Extracted memory example: Users confused by cloud setup during onboarding.

- Extracts concise summaries to preserve critical context and key insights
- Namespace: `/strategies/{memoryStrategyId}/actors/{actorId}/sessions/{sessionId}`

#### Semantic Memory Strategy

Distills general facts, concepts, and underlying meanings from raw conversational data, presenting the information in a context-independent format. Extracted memory example: In-context learning = task-solving via examples, no training needed.

- Extracts general factual knowledge, concepts and meanings from raw conversations
- Namespace: `/strategies/{memoryStrategyId}/actors/{actorId}`

#### User Preference Strategy

Captures individual preferences, interaction patterns, and personalized settings to enhance future experiences. Extracted memory example: User needs clear guidance on cloud storage account connection during onboarding.

- Extracts user behavior patterns from raw conversations
- Namespace: `/strategies/{memoryStrategyId}/actors/{actorId}`

```hcl
module "agentcore" {
  source  = "aws-ia/agentcore/aws"
  version = "0.0.2"

  # Create memory with built-in strategies
  create_memory = true
  memory_name = "my_memory"
  memory_description = "Memory with built-in strategies"
  memory_event_expiry_duration = 90

  # Add built-in memory strategies
  memory_strategies = [
    {
      summarization_memory_strategy = {
        name = "summary_strategy"
        description = "Built-in summarization memory strategy"
        namespaces = ["/strategies/{memoryStrategyId}/actors/{actorId}/sessions/{sessionId}"]
      }
    },
    {
      semantic_memory_strategy = {
        name = "semantic_strategy"
        description = "Built-in semantic memory strategy"
        namespaces = ["/strategies/{memoryStrategyId}/actors/{actorId}"]
      }
    },
    {
      user_preference_memory_strategy = {
        name = "preference_strategy"
        description = "Built-in user preference memory strategy"
        namespaces = ["/strategies/{memoryStrategyId}/actors/{actorId}"]
      }
    }
  ]
}
```

The name generated for each built in memory strategy follows this pattern:

- For Summarization: `summary_builtin_<suffix>`
- For Semantic: `semantic_builtin_<suffix>`
- For User Preferences: `preference_builtin_<suffix>`

Where the suffix is a 5 characters string ([a-z, A-Z, 0-9]).

#### LTM Memory Extraction Stategies

If you need long-term memory for context recall across sessions, you can setup memory extraction strategies to extract the relevant memory from the raw events.

Amazon Bedrock AgentCore Memory has different memory strategies for extracting and organizing information:

- **Summarization**: to summarize interactions to preserve critical context and key insights.
- **Semantic Memory**: to extract general factual knowledge, concepts and meanings from raw conversations using vector embeddings. This enables similarity-based retrieval of relevant facts and context.
- **User Preferences**: to extract user behavior patterns from raw conversations.

You can use built-in extraction strategies for quick setup, or create custom extraction strategies with specific models and prompt templates.

#### Memory with Built-in Strategies - Custom Namespace

With Long-Term Memory, organization is managed through Namespaces.

An `actor` refers to entity such as end users or agent/user combinations. For example, in a coding support chatbot, the actor is usually the developer asking questions. Using the actor ID helps the system know which user the memory belongs to, keeping each user's data separate and organized.

A `session` is usually a single conversation or interaction period between the user and the AI agent. It groups all related messages and events that happen during that conversation.

A `namespace` is used to logically group and organize long-term memories. It ensures data stays neat, separate, and secure.

With AgentCore Memory, you need to add a namespace when you define a memory strategy. This namespace helps define where the long-term memory will be logically grouped. Every time a new long-term memory is extracted using this memory strategy, it is saved under the namespace you set. This means that all long-term memories are scoped to their specific namespace, keeping them organized and preventing any mix-ups with other users or sessions. You should use a hierarchical format separated by forward slashes /. This helps keep memories organized clearly. As needed, you can choose to use the below pre-defined variables within braces in the namespace based on your applications' organization needs:

- `actorId` – Identifies who the long-term memory belongs to, such as a user
- `memoryStrategyId` – Shows which memory strategy is being used. This strategy identifier is auto-generated when you create a memory using CreateMemory operation.
- `sessionId` – Identifies which session or conversation the memory is from.

For example, if you define the following namespace as the input to your strategy:

```shell
/strategy/{memoryStrategyId}/actor/{actorId}/session/{sessionId}
```

After memory creation, this namespace might look like:

```shell
/strategy/summarization-93483043//actor/actor-9830m2w3/session/session-9330sds8
```

You can customize the namespace (where the memories are stored) by configuring the memory strategies in your Terraform configuration:

```hcl
module "agentcore" {
  source  = "aws-ia/agentcore/aws"
  version = "0.0.2"

  # Enable Agent Core Memory
  create_memory = true
  memory_name = "my_memory"
  memory_description = "Memory with built-in strategies"
  memory_event_expiry_duration = 90

  # Configure memory strategies with custom namespaces
  memory_strategies = [
    {
      user_preference_memory_strategy = {
        name = "CustomerPreferences"
        description = "User preference memory strategy"
        namespaces = ["support/customer/{actorId}/preferences"]
      }
    },
    {
      semantic_memory_strategy = {
        name = "CustomerSupportSemantic"
        description = "Semantic memory strategy"
        namespaces = ["support/customer/{actorId}/semantic"]
      }
    }
  ]
}
```

#### Custom Strategies (Built-in strategy with override)

Custom memory strategies let you tailor memory extraction and consolidation to your specific domain or use case. You can override the prompts for extracting and consolidating semantic, summary, or user preferences. You can also choose the model that you want to use for extraction and consolidation.

The custom prompts you create are appended to a non-editable system prompt.

Since a custom strategy requires you to invoke certain Foundation Models, you need a role with appropriate permissions. For that, you can:

- Use a custom role with the overly permissive `AmazonBedrockAgentCoreMemoryBedrockModelInferenceExecutionRolePolicy` managed policy.
- Use a custom role with your own custom policies.

#### Memory with Custom Execution Role

Keep in mind that memories that **do not** use custom strategies do not require a service role. A role is only created automatically when you use custom memory strategies that need to invoke foundation models. For standard built-in strategies (semantic, summary, user preference), no role is needed.

#### Policy Documents for Other Resources

The module also exposes IAM policy documents that you can use to grant memory permissions to other resources (like Lambda functions or EC2 instances):

```hcl
# Create a Lambda function that needs to write to memory
resource "aws_lambda_function" "memory_writer" {
  function_name = "memory-writer"
  # ... other Lambda configuration ...
}

# Create a policy for the Lambda using the provided policy document
resource "aws_iam_policy" "memory_write_policy" {
  name   = "memory-write-policy"
  policy = jsonencode(module.agentcore.memory_stm_write_policy)
}

# Attach the policy to the Lambda role
resource "aws_iam_role_policy_attachment" "memory_write_policy_attachment" {
  role       = aws_lambda_function.memory_writer.role
  policy_arn = aws_iam_policy.memory_write_policy.arn
}
```

Available policy documents include:

- `memory_stm_write_policy` - For STM write permissions
- `memory_read_policy` - For read permissions to both STM and LTM
- `memory_stm_read_policy` - For STM-only read permissions
- `memory_ltm_read_policy` - For LTM-only read permissions
- `memory_delete_policy` - For delete permissions to both STM and LTM
- `memory_stm_delete_policy` - For STM-only delete permissions
- `memory_ltm_delete_policy` - For LTM-only delete permissions
- `memory_admin_policy` - For control plane admin permissions
- `memory_full_access_policy` - For full access to all operations

### AgentCore Browser Custom

The Amazon Bedrock AgentCore Browser provides a secure, cloud-based browser that enables AI agents to interact with websites. It includes security features such as session isolation, built-in observability through live viewing, CloudTrail logging, and session replay capabilities.

Additional information about the browser tool can be found in the official [documentation](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/browser-tool.html).

#### Browser Network modes

The Browser construct supports the following network modes:

1. Public Network Mode - Default

- Allows internet access for web browsing and external API calls
- Suitable for scenarios where agents need to interact with publicly available websites
- Enables full web browsing capabilities
- VPC mode is not supported with this option

2. VPC (Virtual Private Cloud)

- Select whether to run the browser in a virtual private cloud (VPC).
- By configuring VPC connectivity, you enable secure access to private resources such as databases, internal APIs, and services within your VPC.

```hcl
module "agentcore" {
  source  = "aws-ia/agentcore/aws"
  version = "0.0.2"

  # Enable Agent Core Browser Custom
  create_browser = true
  browser_name = "MyBrowser"
  browser_description = "Custom browser for my Bedrock agent"
  browser_network_mode = "PUBLIC"  # PUBLIC or VPC

  # Optional: Enable recording to S3
  browser_recording_enabled = true
  browser_recording_config = {
    bucket = "my-browser-recordings-bucket"
    prefix = "recordings/"
  }

  # Optional: For VPC network mode
  # browser_network_configuration = {
  #   security_groups = ["enter_security_group"]
  #   subnets         = ["enter_subnet"]
  # }

  browser_tags = {
    Environment = "production"
    Project     = "ai-assistants"
  }
}
```

### AgentCore Gateway Target

The Amazon Bedrock AgentCore Gateway Target enables you to define the endpoints and configurations that a gateway can invoke, such as Lambda functions or MCP servers. Gateway targets allow agents to interact with external services through the Model Context Protocol (MCP).

```hcl
module "agentcore" {
  source  = "aws-ia/agentcore/aws"
  version = "0.0.2"

  # First, create a gateway
  create_gateway = true
  gateway_name = "MyGateway"

  # Then create a gateway target for Lambda
  create_gateway_target = true
  gateway_target_name = "MyLambdaTarget"
  gateway_target_description = "Lambda function target for processing requests"

  # Use the gateway's IAM role for authentication
  gateway_target_credential_provider_type = "GATEWAY_IAM_ROLE"

  # Configure the Lambda target
  gateway_target_type = "LAMBDA"
  gateway_target_lambda_config = {
    lambda_arn = "arn:aws:lambda:us-east-1:123456789012:function:my-function"
    tool_schema_type = "INLINE"
    inline_schema = {
      name        = "process_request"
      description = "Process incoming requests"

      input_schema = {
        type        = "object"
        description = "Request processing schema"
        properties = [
          {
            name        = "message"
            type        = "string"
            description = "Message to process"
            required    = true
          },
          {
            name = "options"
            type = "object"
            nested_properties = [
              {
                name = "priority"
                type = "string"
              }
            ]
          }
        ]
      }

      output_schema = {
        type = "object"
        properties = [
          {
            name     = "status"
            type     = "string"
            required = true
          },
          {
            name = "result"
            type = "string"
          }
        ]
      }
    }
  }
}
```

#### Gateway Target with API Key Authentication

```hcl
module "agentcore" {
  source  = "aws-ia/agentcore/aws"
  version = "0.0.2"

  # Create a gateway target with API Key authentication
  create_gateway_target = true
  gateway_target_name = "ApiKeyTarget"
  gateway_target_gateway_id = "your-gateway-id" # If using existing gateway

  gateway_target_credential_provider_type = "API_KEY"
  gateway_target_api_key_config = {
    provider_arn = "arn:aws:iam::123456789012:oidc-provider/example.com"
    credential_location = "HEADER"
    credential_parameter_name = "X-API-Key"
    credential_prefix = "Bearer"
  }

  # Configure Lambda target
  gateway_target_type = "LAMBDA"
  gateway_target_lambda_config = {
    lambda_arn = "arn:aws:lambda:us-east-1:123456789012:function:api-function"
    tool_schema_type = "INLINE"
    inline_schema = {
      name        = "api_tool"
      description = "External API integration tool"

      input_schema = {
        type = "string"
        description = "Simple string input for API calls"
      }
    }
  }
}
```

#### Gateway Target with MCP Server

```hcl
module "agentcore" {
  source  = "aws-ia/agentcore/aws"
  version = "0.0.2"

  # Create a gateway target for an MCP server
  create_gateway_target = true
  gateway_target_name = "MCPServerTarget"

  # Configure MCP Server target
  gateway_target_type = "MCP_SERVER"
  gateway_target_mcp_server_config = {
    endpoint = "https://mcp-server.example.com"
  }
}
```

### AgentCore Workload Identity

The Amazon Bedrock AgentCore Workload Identity enables you to manage identity configurations for resources such as AgentCore runtime and AgentCore gateway. Workload identities provide secure access management and OAuth2 integration capabilities for your Bedrock AI applications.

```hcl
module "agentcore" {
  source  = "aws-ia/agentcore/aws"
  version = "0.0.2"

  # Enable Workload Identity
  create_workload_identity = true
  workload_identity_name = "MyWorkloadIdentity"
  workload_identity_allowed_resource_oauth_2_return_urls = [
    "https://example.com/oauth2/callback",
    "https://api.example.com/auth/callback"
  ]

  # Optional: Add tags
  workload_identity_tags = {
    Environment = "production"
    Project     = "ai-assistants"
  }
}
```

### AgentCore Code Interpreter Custom

The Amazon Bedrock AgentCore Code Interpreter enables AI agents to write and execute code securely in sandbox environments, enhancing their accuracy and expanding their ability to solve complex end-to-end tasks. This is critical in Agentic AI applications where the agents may execute arbitrary code that can lead to data compromise or security risks. The AgentCore Code Interpreter tool provides secure code execution, which helps you avoid running into these issues.

For more information about code interpreter, please refer to the [official documentation](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/code-interpreter-tool.html).

#### Code Interpreter Network Modes

The Code Interpreter construct supports the following network modes:

1. Public Network Mode - Default

- Allows internet access for package installation and external API calls
- Suitable for development and testing environments
- Enables downloading Python packages from PyPI

2. Sandbox Network Mode

- Isolated network environment with no internet access
- Suitable for production environments with strict security requirements
- Only allows access to pre-installed packages and local resources

3. VPC (Virtual Private Cloud)

- Select whether to run the browser in a virtual private cloud (VPC).
- By configuring VPC connectivity, you enable secure access to private resources such as databases, internal APIs, and services within your VPC.

```hcl
module "agentcore" {
  source  = "aws-ia/agentcore/aws"
  version = "0.0.2"

  # Enable Agent Core Code Interpreter Custom
  create_code_interpreter = true
  code_interpreter_name = "MyCodeInterpreter"
  code_interpreter_description = "Custom code interpreter for my Bedrock agent"
  code_interpreter_network_mode = "SANDBOX"  # SANDBOX or VPC

  # Optional: For VPC network mode
  # code_interpreter_network_configuration = {
  #   security_groups = ["enter-sg"]
  #   subnets         = ["enter-subnet"]
  # }

  code_interpreter_tags = {
    Environment = "production"
    Project     = "ai-assistants"
  }
}
```

## Architecture

The module creates the following resources:

1. **Agent Core Runtime**: A container-based runtime environment for your Bedrock agent
2. **IAM Role and Policy**: Permissions for the runtime to access AWS services
3. **Agent Core Runtime Endpoint**: An endpoint for client applications to interact with the runtime
4. **Agent Core Gateway**: A gateway for Model Context Protocol (MCP) connections
5. **Gateway IAM Role and Policy**: Permissions for the gateway to access AWS services

The IAM role includes permissions for:

- ECR image access
- CloudWatch Logs
- X-Ray tracing
- CloudWatch metrics
- Bedrock model invocation
- Workload identity token management

## Prerequisites

To use this module, you need:

1. An AWS account with appropriate permissions
2. Terraform >= 1.0.7
3. AWS provider >= 4.0.0
4. AWSCC provider >= 0.24.0
5. A container image in Amazon ECR (for the runtime)

## Examples

The module includes examples demonstrating different use cases:

### Agent Runtime with STRANDS Framework

The [agent-runtime](./examples/agent-runtime) example demonstrates:

- Creating an ECR repository
- Building and pushing a Docker image
- Creating a Bedrock Agent Runtime and Endpoint
- Implementing a STRANDS framework agent with tool-calling capabilities

This example includes:

- A Python implementation using the STRANDS framework
- Tools for calculations, weather information, and greetings
- Testing scripts for local and deployed testing

## Advanced Configuration

### Network Configuration

The module supports both PUBLIC and VPC network modes:

```hcl
# Public network mode (default)
runtime_network_mode = "PUBLIC"

# VPC network mode (requires additional configuration)
runtime_network_mode = "VPC"
```

### Environment Variables

Pass configuration to your runtime container:

```hcl
runtime_environment_variables = {
  "LOG_LEVEL" = "DEBUG"
  "MODEL_ID" = "anthropic.claude-3-sonnet-20240229-v1:0"
  "MAX_TOKENS" = "4096"
}
```

### Tags

Add tags to your resources:

```hcl
runtime_tags = {
  Environment = "production"
  Project     = "ai-assistants"
  Owner       = "data-science-team"
}

runtime_endpoint_tags = {
  Environment = "production"
  Project     = "ai-assistants"
  Owner       = "data-science-team"
}

memory_tags = {
  Environment = "production"
  Project     = "ai-assistants"
  Owner       = "data-science-team"
}

gateway_tags = {
  Environment = "production"
  Project     = "ai-assistants"
  Owner       = "data-science-team"
}
